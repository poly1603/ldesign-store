# ËÅäÂ§©Â∫îÁî®Á§∫‰æã

Êú¨Á§∫‰æãÂ±ïÁ§∫Â¶Ç‰Ωï‰ΩøÁî® @ldesign/store ÊûÑÂª∫‰∏Ä‰∏™ÂÆûÊó∂ËÅäÂ§©Â∫îÁî®ÔºåÂåÖÊã¨Ê∂àÊÅØÁÆ°ÁêÜ„ÄÅÁî®Êà∑Áä∂ÊÄÅ„ÄÅÂÆûÊó∂ÈÄö‰ø°Á≠âÂäüËÉΩ„ÄÇ

## üéØ ÂäüËÉΩÁâπÊÄß

- ÂÆûÊó∂Ê∂àÊÅØÊî∂Âèë
- Áî®Êà∑Âú®Á∫øÁä∂ÊÄÅ
- Ê∂àÊÅØÂéÜÂè≤ËÆ∞ÂΩï
- Êñá‰ª∂‰∏ä‰º†ÂàÜ‰∫´
- Ê∂àÊÅØÁä∂ÊÄÅÔºàÂ∑≤ËØª/Êú™ËØªÔºâ
- Áæ§ÁªÑËÅäÂ§©ÊîØÊåÅ

## üìÅ È°πÁõÆÁªìÊûÑ

```
src/
‚îú‚îÄ‚îÄ stores/
‚îÇ   ‚îú‚îÄ‚îÄ ChatStore.ts          # ËÅäÂ§©‰∏ª Store
‚îÇ   ‚îú‚îÄ‚îÄ MessageStore.ts       # Ê∂àÊÅØÁÆ°ÁêÜ
‚îÇ   ‚îú‚îÄ‚îÄ UserStore.ts          # Áî®Êà∑Áä∂ÊÄÅ
‚îÇ   ‚îî‚îÄ‚îÄ ConnectionStore.ts    # ËøûÊé•ÁÆ°ÁêÜ
‚îú‚îÄ‚îÄ components/
‚îÇ   ‚îú‚îÄ‚îÄ ChatRoom.vue          # ËÅäÂ§©ÂÆ§ÁªÑ‰ª∂
‚îÇ   ‚îú‚îÄ‚îÄ MessageList.vue       # Ê∂àÊÅØÂàóË°®
‚îÇ   ‚îú‚îÄ‚îÄ MessageInput.vue      # Ê∂àÊÅØËæìÂÖ•
‚îÇ   ‚îî‚îÄ‚îÄ UserList.vue          # Áî®Êà∑ÂàóË°®
‚îî‚îÄ‚îÄ utils/
    ‚îú‚îÄ‚îÄ websocket.ts          # WebSocket Â∑•ÂÖ∑
    ‚îî‚îÄ‚îÄ message.ts            # Ê∂àÊÅØÂ§ÑÁêÜÂ∑•ÂÖ∑
```

## üè™ Store ÂÆûÁé∞

### ËÅäÂ§©‰∏ª Store

```typescript
import { BaseStore, State, Action, Getter } from '@ldesign/store'
import { MessageStore } from './MessageStore'
import { UserStore } from './UserStore'
import { ConnectionStore } from './ConnectionStore'

export class ChatStore extends BaseStore {
  @State
  currentRoom = null

  @State
  rooms = []

  @State
  activeUsers = []

  // Ê≥®ÂÖ•ÂÖ∂‰ªñ Store
  messageStore = new MessageStore()
  userStore = new UserStore()
  connectionStore = new ConnectionStore()

  @Getter
  get currentMessages() {
    return this.messageStore.getMessagesByRoom(this.currentRoom?.id)
  }

  @Getter
  get unreadCount() {
    return this.messageStore.getUnreadCount()
  }

  @Action
  async joinRoom(roomId) {
    try {
      // Á¶ªÂºÄÂΩìÂâçÊàøÈó¥
      if (this.currentRoom) {
        await this.leaveRoom(this.currentRoom.id)
      }

      // Âä†ÂÖ•Êñ∞ÊàøÈó¥
      const room = await api.joinRoom(roomId)
      this.currentRoom = room

      // Âª∫Á´ã WebSocket ËøûÊé•
      await this.connectionStore.connect(roomId)

      // Âä†ËΩΩÂéÜÂè≤Ê∂àÊÅØ
      await this.messageStore.loadMessages(roomId)

      // Ê†áËÆ∞Ê∂àÊÅØ‰∏∫Â∑≤ËØª
      await this.messageStore.markAsRead(roomId)

    } catch (error) {
      console.error('Âä†ÂÖ•ÊàøÈó¥Â§±Ë¥•:', error)
      throw error
    }
  }

  @Action
  async leaveRoom(roomId) {
    if (this.currentRoom?.id === roomId) {
      this.currentRoom = null
      await this.connectionStore.disconnect()
    }
  }

  @Action
  async sendMessage(content, type = 'text') {
    if (!this.currentRoom) return

    const message = {
      id: Date.now().toString(),
      roomId: this.currentRoom.id,
      userId: this.userStore.currentUser.id,
      content,
      type,
      timestamp: Date.now(),
      status: 'sending'
    }

    // ‰πêËßÇÊõ¥Êñ∞
    this.messageStore.addMessage(message)

    try {
      // ÂèëÈÄÅÂà∞ÊúçÂä°Âô®
      const sentMessage = await this.connectionStore.sendMessage(message)
      
      // Êõ¥Êñ∞Ê∂àÊÅØÁä∂ÊÄÅ
      this.messageStore.updateMessage(message.id, {
        ...sentMessage,
        status: 'sent'
      })

    } catch (error) {
      // ÂèëÈÄÅÂ§±Ë¥•ÔºåÊ†áËÆ∞ÈîôËØØÁä∂ÊÄÅ
      this.messageStore.updateMessage(message.id, {
        status: 'failed'
      })
      throw error
    }
  }

  @Action
  async uploadFile(file) {
    const formData = new FormData()
    formData.append('file', file)
    formData.append('roomId', this.currentRoom.id)

    try {
      const response = await api.uploadFile(formData)
      
      await this.sendMessage(response.url, 'file')
      
      return response
    } catch (error) {
      console.error('Êñá‰ª∂‰∏ä‰º†Â§±Ë¥•:', error)
      throw error
    }
  }

  @Action
  updateActiveUsers(users) {
    this.activeUsers = users
  }
}
```

### Ê∂àÊÅØÁÆ°ÁêÜ Store

```typescript
export class MessageStore extends BaseStore {
  @State
  @Persist({ key: 'chat-messages' })
  messages = []

  @State
  @Persist({ key: 'message-status' })
  readStatus = {} // { roomId: lastReadMessageId }

  @Getter
  getMessagesByRoom() {
    return (roomId) => {
      return this.messages
        .filter(msg => msg.roomId === roomId)
        .sort((a, b) => a.timestamp - b.timestamp)
    }
  }

  @Getter
  getUnreadCount() {
    const counts = {}
    
    this.messages.forEach(msg => {
      const lastRead = this.readStatus[msg.roomId]
      if (!lastRead || msg.id > lastRead) {
        counts[msg.roomId] = (counts[msg.roomId] || 0) + 1
      }
    })
    
    return counts
  }

  @Action
  async loadMessages(roomId, limit = 50) {
    try {
      const messages = await api.getMessages(roomId, { limit })
      
      // ÂêàÂπ∂Ê∂àÊÅØÔºåÈÅøÂÖçÈáçÂ§ç
      const existingIds = new Set(this.messages.map(m => m.id))
      const newMessages = messages.filter(m => !existingIds.has(m.id))
      
      this.messages.push(...newMessages)
      
    } catch (error) {
      console.error('Âä†ËΩΩÊ∂àÊÅØÂ§±Ë¥•:', error)
      throw error
    }
  }

  @Action
  addMessage(message) {
    // Ê£ÄÊü•ÊòØÂê¶Â∑≤Â≠òÂú®
    const exists = this.messages.find(m => m.id === message.id)
    if (!exists) {
      this.messages.push(message)
    }
  }

  @Action
  updateMessage(messageId, updates) {
    const index = this.messages.findIndex(m => m.id === messageId)
    if (index !== -1) {
      this.messages[index] = { ...this.messages[index], ...updates }
    }
  }

  @Action
  markAsRead(roomId) {
    const roomMessages = this.getMessagesByRoom(roomId)
    if (roomMessages.length > 0) {
      const lastMessage = roomMessages[roomMessages.length - 1]
      this.readStatus[roomId] = lastMessage.id
    }
  }

  @Action
  @Debounce(1000)
  async syncReadStatus() {
    try {
      await api.updateReadStatus(this.readStatus)
    } catch (error) {
      console.error('ÂêåÊ≠•Â∑≤ËØªÁä∂ÊÄÅÂ§±Ë¥•:', error)
    }
  }
}
```

### ËøûÊé•ÁÆ°ÁêÜ Store

```typescript
export class ConnectionStore extends BaseStore {
  @State
  connected = false

  @State
  reconnecting = false

  @State
  connectionError = null

  private ws = null
  private reconnectTimer = null
  private heartbeatTimer = null

  @Action
  async connect(roomId) {
    if (this.ws) {
      this.ws.close()
    }

    try {
      this.ws = new WebSocket(`ws://localhost:8080/chat/${roomId}`)
      
      this.ws.onopen = () => {
        this.connected = true
        this.reconnecting = false
        this.connectionError = null
        this.startHeartbeat()
      }

      this.ws.onmessage = (event) => {
        this.handleMessage(JSON.parse(event.data))
      }

      this.ws.onclose = () => {
        this.connected = false
        this.stopHeartbeat()
        this.scheduleReconnect(roomId)
      }

      this.ws.onerror = (error) => {
        this.connectionError = error.message
      }

    } catch (error) {
      this.connectionError = error.message
      throw error
    }
  }

  @Action
  async disconnect() {
    if (this.ws) {
      this.ws.close()
      this.ws = null
    }
    
    this.clearTimers()
    this.connected = false
    this.reconnecting = false
  }

  @Action
  async sendMessage(message) {
    if (!this.connected || !this.ws) {
      throw new Error('ËøûÊé•Êú™Âª∫Á´ã')
    }

    return new Promise((resolve, reject) => {
      const messageWithId = { ...message, id: Date.now().toString() }
      
      this.ws.send(JSON.stringify({
        type: 'message',
        data: messageWithId
      }))

      // ÁÆÄÂåñÂ§ÑÁêÜÔºåÂÆûÈôÖÂ∫îËØ•Á≠âÂæÖÊúçÂä°Âô®Á°ÆËÆ§
      setTimeout(() => resolve(messageWithId), 100)
    })
  }

  @Action
  private handleMessage(data) {
    const chatStore = useChatStore()
    const messageStore = chatStore.messageStore

    switch (data.type) {
      case 'message':
        messageStore.addMessage(data.message)
        break
        
      case 'user_joined':
        chatStore.updateActiveUsers(data.users)
        break
        
      case 'user_left':
        chatStore.updateActiveUsers(data.users)
        break
        
      case 'typing':
        // Â§ÑÁêÜÊâìÂ≠óÁä∂ÊÄÅ
        break
    }
  }

  @Action
  private scheduleReconnect(roomId) {
    if (this.reconnectTimer) return

    this.reconnecting = true
    
    this.reconnectTimer = setTimeout(() => {
      this.connect(roomId)
      this.reconnectTimer = null
    }, 3000)
  }

  @Action
  private startHeartbeat() {
    this.heartbeatTimer = setInterval(() => {
      if (this.ws && this.connected) {
        this.ws.send(JSON.stringify({ type: 'ping' }))
      }
    }, 30000)
  }

  @Action
  private stopHeartbeat() {
    if (this.heartbeatTimer) {
      clearInterval(this.heartbeatTimer)
      this.heartbeatTimer = null
    }
  }

  @Action
  private clearTimers() {
    if (this.reconnectTimer) {
      clearTimeout(this.reconnectTimer)
      this.reconnectTimer = null
    }
    this.stopHeartbeat()
  }
}
```

## üé® Vue ÁªÑ‰ª∂

### ËÅäÂ§©ÂÆ§ÁªÑ‰ª∂

```vue
<template>
  <div class="chat-room">
    <div class="chat-header">
      <h3>{{ currentRoom?.name }}</h3>
      <div class="connection-status">
        <span :class="connectionClass">
          {{ connectionStatus }}
        </span>
      </div>
    </div>

    <div class="chat-content">
      <MessageList 
        :messages="currentMessages"
        @load-more="loadMoreMessages"
      />
      
      <MessageInput 
        @send="sendMessage"
        @upload="uploadFile"
        :disabled="!connected"
      />
    </div>

    <UserList 
      :users="activeUsers"
      class="user-sidebar"
    />
  </div>
</template>

<script setup lang="ts">
import { computed } from 'vue'
import { useChatStore } from '@/stores/ChatStore'

const chatStore = useChatStore()

const currentRoom = computed(() => chatStore.currentRoom)
const currentMessages = computed(() => chatStore.currentMessages)
const activeUsers = computed(() => chatStore.activeUsers)
const connected = computed(() => chatStore.connectionStore.connected)
const reconnecting = computed(() => chatStore.connectionStore.reconnecting)

const connectionStatus = computed(() => {
  if (reconnecting.value) return 'ÈáçËøû‰∏≠...'
  if (connected.value) return 'Â∑≤ËøûÊé•'
  return 'Êú™ËøûÊé•'
})

const connectionClass = computed(() => ({
  'status-connected': connected.value,
  'status-reconnecting': reconnecting.value,
  'status-disconnected': !connected.value && !reconnecting.value
}))

const sendMessage = async (content: string) => {
  try {
    await chatStore.sendMessage(content)
  } catch (error) {
    // ÊòæÁ§∫ÈîôËØØÊèêÁ§∫
    console.error('ÂèëÈÄÅÊ∂àÊÅØÂ§±Ë¥•:', error)
  }
}

const uploadFile = async (file: File) => {
  try {
    await chatStore.uploadFile(file)
  } catch (error) {
    console.error('Êñá‰ª∂‰∏ä‰º†Â§±Ë¥•:', error)
  }
}

const loadMoreMessages = async () => {
  if (currentRoom.value) {
    await chatStore.messageStore.loadMessages(currentRoom.value.id)
  }
}
</script>

<style scoped>
.chat-room {
  display: flex;
  height: 100vh;
  background: #f5f5f5;
}

.chat-content {
  flex: 1;
  display: flex;
  flex-direction: column;
}

.chat-header {
  display: flex;
  justify-content: space-between;
  align-items: center;
  padding: 1rem;
  background: white;
  border-bottom: 1px solid #e0e0e0;
}

.connection-status {
  font-size: 0.875rem;
}

.status-connected {
  color: #4caf50;
}

.status-reconnecting {
  color: #ff9800;
}

.status-disconnected {
  color: #f44336;
}

.user-sidebar {
  width: 200px;
  background: white;
  border-left: 1px solid #e0e0e0;
}
</style>
```

## üöÄ ‰ΩøÁî®ÊñπÂºè

### 1. ÂàùÂßãÂåñËÅäÂ§©

```typescript
// main.ts
import { createApp } from 'vue'
import { createPinia } from 'pinia'
import { useChatStore } from '@/stores/ChatStore'

const app = createApp(App)
app.use(createPinia())

// ÂàùÂßãÂåñËÅäÂ§© Store
const chatStore = useChatStore()

// Âä†ÂÖ•ÈªòËÆ§ÊàøÈó¥
chatStore.joinRoom('general')
```

### 2. Âú®ÁªÑ‰ª∂‰∏≠‰ΩøÁî®

```vue
<script setup>
import { useChatStore } from '@/stores/ChatStore'

const chatStore = useChatStore()

// ÂèëÈÄÅÊ∂àÊÅØ
const sendMessage = (content) => {
  chatStore.sendMessage(content)
}

// ÂàáÊç¢ÊàøÈó¥
const switchRoom = (roomId) => {
  chatStore.joinRoom(roomId)
}
</script>
```

## üì± ÁßªÂä®Á´ØÈÄÇÈÖç

```vue
<template>
  <div class="mobile-chat" :class="{ 'sidebar-open': sidebarOpen }">
    <!-- ÁßªÂä®Á´ØÂ∏ÉÂ±Ä -->
  </div>
</template>

<style>
@media (max-width: 768px) {
  .chat-room {
    flex-direction: column;
  }
  
  .user-sidebar {
    position: fixed;
    top: 0;
    right: -200px;
    height: 100vh;
    transition: right 0.3s ease;
  }
  
  .sidebar-open .user-sidebar {
    right: 0;
  }
}
</style>
```

## üéØ ÁâπÊÄßËØ¥Êòé

### ÂÆûÊó∂ÈÄö‰ø°
- WebSocket ËøûÊé•ÁÆ°ÁêÜ
- Ëá™Âä®ÈáçËøûÊú∫Âà∂
- ÂøÉË∑≥Ê£ÄÊµã

### Ê∂àÊÅØÁÆ°ÁêÜ
- Ê∂àÊÅØÊåÅ‰πÖÂåñ
- Â∑≤ËØªÁä∂ÊÄÅÂêåÊ≠•
- ‰πêËßÇÊõ¥Êñ∞

### Áî®Êà∑‰ΩìÈ™å
- ËøûÊé•Áä∂ÊÄÅÊòæÁ§∫
- ÂèëÈÄÅÁä∂ÊÄÅÂèçÈ¶à
- Á¶ªÁ∫øÊ∂àÊÅØÁºìÂ≠ò

### ÊÄßËÉΩ‰ºòÂåñ
- Ê∂àÊÅØÂàÜÈ°µÂä†ËΩΩ
- Èò≤ÊäñÂ§ÑÁêÜ
- ÂÜÖÂ≠òÁÆ°ÁêÜ

Ëøô‰∏™ËÅäÂ§©Â∫îÁî®Á§∫‰æãÂ±ïÁ§∫‰∫ÜÂ¶Ç‰Ωï‰ΩøÁî® @ldesign/store ÊûÑÂª∫Â§çÊùÇÁöÑÂÆûÊó∂Â∫îÁî®ÔºåÂåÖÂê´‰∫ÜÁä∂ÊÄÅÁÆ°ÁêÜ„ÄÅÂÆûÊó∂ÈÄö‰ø°„ÄÅÊï∞ÊçÆÊåÅ‰πÖÂåñÁ≠âÂ§ö‰∏™ÊñπÈù¢ÁöÑÊúÄ‰Ω≥ÂÆûË∑µ„ÄÇ
